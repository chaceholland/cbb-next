#!/usr/bin/env node
/**
 * Rescrape headshots for teams with poor coverage (<50%)
 * Uses the teams-needing-headshot-rescrape.json file generated by analyze-headshot-coverage.mjs
 */

import { createClient } from '@supabase/supabase-js';
import * as dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs';
import pwPkg from '@playwright/test';
const { chromium } = pwPkg;

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

dotenv.config({ path: join(__dirname, '.env.local') });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('âŒ Missing Supabase credentials');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

// Normalize name for matching
const norm = name => name?.toLowerCase().replace(/[^a-z\s]/g, '').replace(/\s+/g, ' ').trim() ?? '';

// Load teams needing rescraping
const teamsToRescrape = JSON.parse(fs.readFileSync('teams-needing-headshot-rescrape.json', 'utf8'));

async function findHeadshotOnPage(page) {
  return await page.evaluate(() => {
    const allImages = [...document.querySelectorAll('img')];

    // Look for player headshot with multiple strategies
    for (const img of allImages) {
      const alt = (img.alt || '').toLowerCase();
      const src = img.currentSrc || img.src || '';
      const className = (img.className || '').toLowerCase();

      // Skip if data URI, logo, or too small
      if (src.includes('data:image') ||
          src.includes('/logo') ||
          img.naturalWidth < 80) {
        continue;
      }

      // Strategy 1: Alt text contains player indicators
      if (alt.includes('headshot') ||
          alt.includes('mug') ||
          alt.includes('player') ||
          alt.includes('portrait')) {
        return src;
      }

      // Strategy 2: Class name indicates headshot
      if (className.includes('headshot') ||
          className.includes('player') ||
          className.includes('portrait')) {
        return src;
      }

      // Strategy 3: Image is reasonably sized for a headshot (100-600px)
      if (img.naturalWidth >= 100 &&
          img.naturalWidth <= 600 &&
          img.naturalHeight >= 100) {
        return src;
      }
    }

    return null;
  });
}

async function scrapeTeamHeadshots(browser, team) {
  console.log(`\n${'='.repeat(80)}`);
  console.log(`ðŸŽ¯ Scraping: ${team.team_name} (${team.coverage_pct}% coverage)`);
  console.log(`${'='.repeat(80)}\n`);

  // Get pitchers for this team that are missing headshots
  const { data: pitchers, error } = await supabase
    .from('cbb_pitchers')
    .select('pitcher_id, name, espn_link, headshot')
    .eq('team_id', team.team_id)
    .or('headshot.is.null,headshot.eq.');

  if (error) {
    console.error(`âŒ Error fetching pitchers: ${error.message}`);
    return { updated: 0, failed: 0 };
  }

  if (!pitchers || pitchers.length === 0) {
    console.log('âœ… No pitchers missing headshots');
    return { updated: 0, failed: 0 };
  }

  console.log(`Found ${pitchers.length} pitchers missing headshots\n`);

  const page = await browser.newPage();
  let updated = 0;
  let failed = 0;

  for (const pitcher of pitchers) {
    try {
      // Skip if no ESPN link
      if (!pitcher.espn_link) {
        console.log(`â­ï¸  ${pitcher.name}: No ESPN link`);
        failed++;
        continue;
      }

      console.log(`  Scraping: ${pitcher.name}`);

      await page.goto(pitcher.espn_link, {
        waitUntil: 'domcontentloaded',
        timeout: 15000
      });

      // Wait for page to load and scroll to trigger lazy loading
      await page.waitForTimeout(2000);
      await page.evaluate(() => window.scrollBy(0, 500));
      await page.waitForTimeout(1000);

      const headshot = await findHeadshotOnPage(page);

      if (headshot) {
        // Update database
        const { error: updateError } = await supabase
          .from('cbb_pitchers')
          .update({ headshot })
          .eq('pitcher_id', pitcher.pitcher_id);

        if (updateError) {
          console.log(`    âŒ Failed to update: ${updateError.message}`);
          failed++;
        } else {
          console.log(`    âœ… Updated headshot`);
          updated++;
        }
      } else {
        console.log(`    âš ï¸  No headshot found`);
        failed++;
      }

    } catch (err) {
      console.log(`    âŒ Error: ${err.message}`);
      failed++;
    }
  }

  await page.close();

  console.log(`\nðŸ“Š ${team.team_name} Summary: ${updated} updated, ${failed} failed\n`);

  return { updated, failed };
}

async function main() {
  console.log('ðŸš€ Starting headshot rescraping for teams with poor coverage\n');
  console.log(`Teams to process: ${teamsToRescrape.length}\n`);

  const browser = await chromium.launch({ headless: true });

  const results = {
    totalUpdated: 0,
    totalFailed: 0,
    teamResults: []
  };

  try {
    for (const team of teamsToRescrape) {
      const result = await scrapeTeamHeadshots(browser, team);
      results.totalUpdated += result.updated;
      results.totalFailed += result.failed;
      results.teamResults.push({
        team_name: team.team_name,
        ...result
      });

      // Small delay between teams
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  } finally {
    await browser.close();
  }

  console.log('\n' + '='.repeat(80));
  console.log('ðŸ“ˆ FINAL RESULTS');
  console.log('='.repeat(80));
  console.log(`\nTotal headshots updated: ${results.totalUpdated}`);
  console.log(`Total failed: ${results.totalFailed}`);
  console.log(`Success rate: ${((results.totalUpdated / (results.totalUpdated + results.totalFailed)) * 100).toFixed(1)}%\n`);

  // Save detailed results
  fs.writeFileSync(
    'headshot-rescrape-results.json',
    JSON.stringify(results, null, 2)
  );
  console.log('ðŸ’¾ Saved detailed results to: headshot-rescrape-results.json\n');
}

main().catch(console.error);
